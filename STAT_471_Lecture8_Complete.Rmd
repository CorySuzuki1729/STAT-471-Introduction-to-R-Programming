---
title: "R Notebook"
output: html_notebook
---

### **Introductory SQL and Applications in R**

We have seen how dplyr can transform and create datasets, but we have not unlocked the full potential of data engineering, a subdiscipline that all data scientists and analysts should learn to keep their skillset repertoires fresh. To do this, we will see how SQL can be utilized to extract, create, and transform datasets with SQL queries embedded in the R language.

<br>

### Database Fundamentals and Data Creation Using DDL

To create data, we can use the DDL keywords that we learned from the conceptual lecture slides. Before we begin, we need to set some ground rules to set up our database connection.

Note that database connections must always be established prior to query construction and must be appropriately closed afterwards. Think of this like opening a book, reading some chapters, and then closing the book once you're done.

The database host we will be using for this class is SQLite which allows you to write SQL queries within your R code. I recommend taking a look at other good hosts such as Postgre SQL, Oracle SQL, and MySQL. These are excellent hosts that also can be used for database management, creation, and manipulation.

```{r}

# Make sure to install the RSQLite package prior to using it in your R session.

# Then run the library and its Database interface (DBI) library.

# install.packages("RSQLite")
library(DBI)
library(RSQLite)
```

Now we establish a connection with the database. dbname refers to the database name, and if it doesn't exist, it creates a new database with that name.

```{r}
connect1 = dbConnect(RSQLite::SQLite(),
                     dbname = "sample_database.sqlite")
```

```{r}
dbExecute(connect1, "
           Create Table Students(
           StudentID Integer Primary Key,
           FirstName Varchar(20) Not Null,
           LastName Varchar(20) Not Null,
           Age Integer,
           GPA Real
           );
           ")
```

Let's insert some data into the Students Table.

```{r}
dbExecute(connect1, "
          Insert Into Students (FirstName, LastName, Age, GPA) Values ('Khirby', 'Calma', 23, 3.56);")

dbExecute(connect1, "
          Insert Into Students (FirstName, LastName, Age, GPA) Values ('John', 'Casaje', 78, 3.43);")

dbExecute(connect1, "
          Insert Into Students (FirstName, LastName, Age, GPA) Values ('Sonny', 'Luong', 26, 4.00);")

dbExecute(connect1, "
          Insert Into Students (FirstName, LastName, Age, GPA) Values ('Haru', 'Urara', 45, 2.98);")

dbGetQuery(connect1, "
           Select * From Students;")
```

Notice that dbExecute() executes your queries without displaying actual output and only displays how many rows were created or modified. Meanwhile, dbgetQuery() returns the results of your query in a dataframe format. 

<br>

### Database Data Insertion and Updates with DDL and DML

Let's now try updating some of these values in our table. We'll update a particular student's GPA and update all StudentID's for existing students.

```{r}

# This query updates the GPA for the student with StudentID of 2.

dbExecute(connect1, "
          Update Students
          Set GPA = 1.45
          Where StudentID = 2")

# This query updates all StudentID's to specific values for all rows. Note that to update all rows with unique StudentID's, we'll need to use the CASE WHEN THEN ELSE syntax as shown here.

dbExecute(connect1, "
          Update Students
          Set StudentID = Case
          When StudentID = 1 Then 025748
          When StudentID = 2 Then 078357
          When StudentID = 3 Then 123456
          When StudentID = 4 Then 510574
          Else StudentID
          End
          Where StudentID In (1,2,3,4);")

dbGetQuery(connect1, "
           Select * From Students;")
```

Now here is an example of deleting a row of data.

```{r}
dbExecute(connect1, "
          Delete From Students
          Where StudentID = 025748;")

dbGetQuery(connect1, "
           Select * From Students;")
```

Once you are done with your queries (or are stopping and will continue modifying the database later after saving your rmd file), make sure to close the connection to the database that you opened before. This ensures that your data is accurate (data integrity) and that all transactions from your queries are committed and not undone by the Database Interface within R.

```{r}
dbDisconnect(connect1)
```

### Joins, Joins, Joins, Everywhere

Let's now practice on joining tables.

```{r}
connect1 = dbConnect(RSQLite::SQLite(),
                     dbname = "sample_database.sqlite")
```

```{r}

# The first two lines drop the tables used for this example to start fresh/debug tables.

#dbExecute(connect1, "Drop Table Students;")
#dbExecute(connect1, "Drop Table Faculty;")

dbExecute(connect1, "
          Create Table Students(
          IDNumber Integer Primary Key,
          FirstName Varchar(50) Not Null,
          LastName Varchar(50) Not Null,
          Age Integer,
          GPA Real
          );")

dbExecute(connect1, "
          Insert Into Students ( FirstName, LastName, Age, GPA) Values ( 'Kitasan', 'Black', 32, 3.55);")

dbExecute(connect1, "
          Insert Into Students ( FirstName, LastName, Age, GPA) Values ('Shohei', 'Ohtani', 36, 4.32);")

dbExecute(connect1, "
          Insert Into Students ( FirstName, LastName, Age, GPA) Values ('Daniel', 'Larusso', 75, 2.31);")

dbExecute(connect1, "
          Create Table Faculty(
          FacultyID Integer Primary Key,
          IDNumber Integer,
          FirstName Varchar(50) Not Null,
          LastName Varchar(50) Not Null,
          Age Integer,
          Tenure Boolean,
          RMP_Rating Real,
          Foreign Key (IDNumber) References Students(IDNumber)
          );")

dbExecute(connect1, "
          Insert Into Faculty (IDNumber, FirstName, LastName, Age, Tenure, RMP_Rating) Values (1, 'Tangan', 'Gao', 65, True, 5.0);")

dbExecute(connect1, "
          Insert Into Faculty (IDNumber, FirstName, LastName, Age, Tenure, RMP_Rating) Values (2, 'Zoe', 'Arias', 27, False, 4.7);")

dbExecute(connect1, "
          Insert Into Faculty (IDNumber, FirstName, LastName, Age, Tenure, RMP_Rating) Values (3, 'Brian', 'Kwan', 34, True, 4.6);")

dbGetQuery(connect1, "
           Select * From Students")

dbGetQuery(connect1, "
           Select * From Faculty")

```

Now let's join these tables with an Inner Join.

```{r}
dbGetQuery(connect1, "
          Select Students.IDNumber, Students.FirstName, Students.LastName, Students.GPA, Faculty.IDNumber, Faculty.FirstName, Faculty.LastName, Faculty.RMP_Rating
          From Students
          Inner Join Faculty
          On Students.IDNumber = Faculty.IDNumber;")
```

Now what happens when we do left and right joins?

```{r}
# Left join

dbGetQuery(connect1, "
          Select Students.IDNumber, Students.FirstName, Students.LastName, Students.GPA, Faculty.IDNumber, Faculty.FirstName, Faculty.LastName, Faculty.RMP_Rating
          From Students
          Left Join Faculty
          On Students.IDNumber = Faculty.IDNumber;")
```

```{r}
# Right Join

dbGetQuery(connect1, "
          Select Students.IDNumber, Students.FirstName, Students.LastName, Students.GPA, Faculty.IDNumber, Faculty.FirstName, Faculty.LastName, Faculty.RMP_Rating
          From Students
          Right Join Faculty
          On Students.IDNumber = Faculty.IDNumber;")
```

Luckily since the IDNumber attributes in both the Students and Faculty tables match, no null values were produced when doing the left and right joins. This is the "perfect" scenario, but real life data isn't going to always be clean like this after doing joins. Let's close the connection and see some examples with some familiar datasets.

```{r}
dbDisconnect(connect1)
```

<br>

### Applying SQL to Datasets

Now let's further our SQL knowledge with some useful applications. We will be first referring to the mtcars built-in dataset. Let's set up a new connection that creates a new database called CarsDB.

```{r}

# Load in the mtcars dataset and ensure that the row names are represented by columns.

data("mtcars")
mtcars$car_names = rownames(mtcars)
rownames(mtcars) = c()
head(mtcars)

# Starting a new connection to the database creation here.

connect2 = dbConnect(RSQLite::SQLite(),
                     dbname ="CarsDB.db")
```

Before, we saw how to create tables using SQL the old fashioned way. Now to unleash the full power of SQL and R combined, let's make the mtcars dataframe into a database table using dbWriteTable(). To check all existing tables are created in your database, you can use dbListTables()

```{r}
dbWriteTable(connect2, "cars_data", mtcars)

dbListTables(connect2)
```

One cool thing you can do with SQLite is that you can append more dataframes to an existing table using a for loop. Here's an example.

```{r}
car = c('Camaro', 'California', 'Mustang', 'Explorer')
make = c('Chevrolet', 'Ferrari', 'Ford', 'Ford')
df1 = data.frame(car, make)

car = c('Corolla', 'Lancer', 'Sportage', 'XE')
make = c('Toyota', 'Mistubishi', 'Kia', 'Land Rover')
df2 = data.frame(car, make)

dfList = list(df1, df2)

for (i in 1:length(dfList)) {
  dbWriteTable(connect2, "Cars_and_Makes", dfList[[i]], append = TRUE)
}

dbListTables(connect2)

dbGetQuery(connect2, "
           Select * From Cars_and_Makes;")
```

And voila, we have combined the dataframes, put them as a list, and then used the append = TRUE parameter to append the data into one singular table.

```{r}

# The following query displays the first 10 rows of the mtcars table. It works just like head(mtcars, 10).

dbGetQuery(connect2, "
           Select * From cars_data
           Limit 10;")
```

Now for some data retrieval with SQL. What if we wanted to return the car names and respective horsepowers of cars with 8 cylinders?

```{r}
dbGetQuery(connect2, "
           Select car_names, hp, cyl
           From cars_data
           Where cyl = 8;")
```

And how about retrieving the average horsepower and mpg by number of cylinder groups?

```{r}
dbGetQuery(connect2, "
           Select cyl, AVG(hp) as 'average_hp', AVG(mpg) as 'average_mpg'
           From cars_data
           Group By cyl
           Order By average_hp;")
```

AVG() calculates the mean of a numerical attribute and 'average_hp' is called an alias, which is a way to reference the mean instead of calling AVG() every single time (similar to variable assignment in R). To save the results of your query, just assign the query to an object.

```{r}
library(tidyverse)

cars_data = dbGetQuery(connect2, "
           Select cyl, AVG(hp) as 'average_hp', AVG(mpg) as 'average_mpg'
           From cars_data
           Group By cyl
           Order By average_hp;")

# The below codes provide line plots with the x axis representing the number of cylinders and the y axis representing the average horsepower and average mpg respectively.

ggplot(data = cars_data, aes(x = cyl, y = average_hp)) +
  geom_line() + geom_point()

ggplot(data = cars_data, aes(x = cyl, y = average_mpg)) +
  geom_line() + geom_point()

```
```{r}
dbDisconnect(connect2)
```

Based on the plots from the queried data, we can conclude that the average horsepower increases as the number of cylinders increase. In contrast, the average mpg decreases as the number of cylinders increase.

This lecture is merely a taste of what you can do with the power of SQL and R implementations in example workflows. This will be especially helpful in industry if you are pulling data from databases to transform and analyze. In fact, there are many additional techniques such as creating indexes, window functions, and etc. 

I recommend "The Language of SQL" by Larry Rockoff and "SQL for Data Scientists" by Renee Teate, as they are excellent references that provide a solid understanding of more advanced concepts and tricks. I can guarantee you that if you apply for data analyst, data scientist, or data engineering positions, more than likely you may be asked about SQL and queries during technical interviews.

<br>
