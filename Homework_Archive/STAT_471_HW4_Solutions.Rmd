---
title: "R Notebook"
output: html_notebook
---

### STAT 471 HW4 Solutions

### Problem 1

```{r}
sim1 = rexp(50, rate=0.8)
sim2 = rexp(1000, rate=0.8)
sim3 = rexp(10000, rate=0.8)

hist(sim1, xlab="Values", ylab="Frequency", main="Exponential Simulation 1")

hist(sim2, xlab="Values", ylab="Frequency", main="Exponential Simulation 2")

hist(sim3, xlab="Values", ylab="Frequency", main="Exponential Simulation 3")

mean(sim1)
mean(sim2)
mean(sim3)
```

(a) As seen in the histograms, the Exponential distribution doesn't look normal here, but if we take the means of each of our simulations, they appear to be approximately normal, which makes sense since the CLT states that the standardized sample mean approaches a N(0,1) distribution asymptotically (as the sample size n gets larger). Hence CLT applies here even though the shape of our sampled simulations aren't exactly quite normal.

(b) For the LLN, the sample means are slightly deviating from the true mean (1/lambda or 1/rate in the context of R syntax), but they are close to 1/0.8 or 1.25. It can be concluded that LLN applies here, although we would need to play around with larger sample sizes to see if these results stay consistent.

<br>

### Problem 2

```{r}
n_samp = 1000
mix_probs = c(0.7, 0.3)

# Generate component labels
component_labels = sample(1:2, size = n_samp, replace = TRUE, prob = mix_probs)

# Initialize vector for mixture samples
mixture_samples = numeric(n_samp)

# Sample from each component based on labels
for (i in 1:n_samp) {
  if (component_labels[i] == 1) {
    mixture_samples[i] = rgamma(n_samp, 2, 3)
  } else {
    mixture_samples[i] = rgamma(n_samp, 4, 5)
  }
}

# Plot histogram of the simulated mixture
hist(mixture_samples, breaks = 30, main = "Simulated Mixture of Two Gammas")

```

### Problem 3

The CDF can be found by integrating the pdf using the given support on (0,1). Doing this results in x^3 being the CDF where x is in (0,1). Thus the inverse CDF is u^(1/3).

```{r}
n_samps = 500
u = runif(n_samps)
inverse_samps = u^(1/3)
hist(inverse_samps, prob=TRUE)

# Optional overlay of probability density function.

y = seq(0, 1, .01)
lines(y, 3*y^2)
```

### Problem 4

```{r}
simBM = function(n, T) {
  times = seq(0, T, length=n+1)
  z = rnorm(n)
  w = rep(0, n)
  s = sqrt(diff(times))
  for (i in 2:n) {
    w[i] = w[i-1] + s[i] * z[i]
  }
  return (list(w=w, t=times))
}

set.seed(42)

n = 200
x1 = simBM(n, 1)
x2 = simBM(n, 1)
x3 = simBM(n, 1)
r = range(c(x1$w, x2$w, x3$w))
plot(x1$w, type="l", main="", xlab="t", ylab="W", ylim=r)
lines(x2$w, lty=2)
lines(x3$w, lty=3)

```

